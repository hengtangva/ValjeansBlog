{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{389:function(t,v,_){t.exports=_.p+\"assets/img/binary_framing.ae09920e.svg\"},390:function(t,v,_){t.exports=_.p+\"assets/img/stream.d7598872.svg\"},486:function(t,v,_){\"use strict\";_.r(v);var p=_(42),a=Object(p.a)({},(function(){var t=this,v=t.$createElement,p=t._self._c||v;return p(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[p(\"h1\",{attrs:{id:\"htpp-1-0-1-1-2-0-3-0\"}},[p(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#htpp-1-0-1-1-2-0-3-0\"}},[t._v(\"#\")]),t._v(\" htpp 1.0/1.1/2.0/3.0\")]),t._v(\" \"),p(\"h2\",{attrs:{id:\"前言\"}},[p(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#前言\"}},[t._v(\"#\")]),t._v(\" 前言\")]),t._v(\" \"),p(\"h2\",{attrs:{id:\"http-2-0\"}},[p(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http-2-0\"}},[t._v(\"#\")]),t._v(\" http 2.0\")]),t._v(\" \"),p(\"p\",[t._v(\"这里先主要讲一下 http 2.0\")]),t._v(\" \"),p(\"p\",[t._v(\"提到 2.0  当然就得先提到 1.1 有哪些问题，然后 2.0 是如何解决这些问题的。\")]),t._v(\" \"),p(\"ol\",[p(\"li\",[p(\"p\",[t._v(\"一个 tcp 连接上，一次只能发送一个请求，如果有多个请求，就会排队等待。\")])]),t._v(\" \"),p(\"li\",[p(\"p\",[t._v(\"头部冗余，采用文本格式传输。\")])]),t._v(\" \"),p(\"li\",[p(\"p\",[t._v(\"客户端需要主动发送请求。\")])])]),t._v(\" \"),p(\"p\",[t._v(\"再来看 http2.0 是如何解决这些问题的。\")]),t._v(\" \"),p(\"h3\",{attrs:{id:\"多路复用\"}},[p(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#多路复用\"}},[t._v(\"#\")]),t._v(\" 多路复用\")]),t._v(\" \"),p(\"p\",[t._v(\"名如其意， 多路复用就是考虑，让一个 tcp 连接能同时发送多个请求，当然和进程一下，这里是并行，不是并发。\")]),t._v(\" \"),p(\"p\",[t._v(\"如下图：\")]),t._v(\" \"),p(\"p\",[t._v(\"想要实现该如何做到呢？\")]),t._v(\" \"),p(\"p\",[t._v(\"我们先来想象一下，多个请求并发的情况是如何。\")]),t._v(\" \"),p(\"p\",[t._v(\"建立一个 tcp 连接后，客户端发一个请求，只有等到服务器返回响应了，才能发送下一个请求。\")]),t._v(\" \"),p(\"p\",[t._v(\"但 http2 不一样，它可以在第一个请求还没收到响应就继续发另请求，\")]),t._v(\" \"),p(\"p\",[t._v(\"带来的好处是，各个请求到接受反应的时间大大缩小。\")]),t._v(\" \"),p(\"p\",[t._v(\"但也带来一个问题，就是比如第一个请求稍有些延迟，后一个请求先到了，并且后一个响应也先到浏览器这边。\")]),t._v(\" \"),p(\"p\",[t._v(\"那么我怎么才能知道，哪个请求对应的响应是哪个呢？\")]),t._v(\" \"),p(\"p\",[t._v(\"这时候就需要对发的数据进行编号，这也正是我们的 http2 所干的事情。\")]),t._v(\" \"),p(\"hr\"),t._v(\" \"),p(\"p\",[t._v(\"我们这里还要说到一个概念  \"),p(\"strong\",[t._v(\"二进制分帧层\")])]),t._v(\" \"),p(\"p\",[t._v(\"二进制分帧层介于应用层和传输层之间\")]),t._v(\" \"),p(\"p\",[t._v(\"它会把 http2 传输的信息分隔为帧(frame)，并对他们采取二进制格式的编码，其中首部信息会被封装到 headers frame 中， request body 的数据则封装到 data frame 中，如下图所示\")]),t._v(\" \"),p(\"p\",[p(\"img\",{attrs:{src:_(389),alt:\"\"}})]),t._v(\" \"),p(\"p\",[t._v(\"到这里我们了解了。\")]),t._v(\" \"),p(\"p\",[t._v(\"http2 主要是把 http报文 分为更小的数据块(帧)，并标记，编码成二进制。从而达到并行发送的效果，接收方，只需按照标记的规则把数据重组为 http 报文就 ok 了\")]),t._v(\" \"),p(\"hr\"),t._v(\" \"),p(\"p\",[t._v(\"再接着了解一下几个概念，方便我们对后面的过程有更清楚的了解。\")]),t._v(\" \"),p(\"ol\",[p(\"li\",[p(\"p\",[t._v(\"数据流： 已经建立连接内的双向字节流(一条发送，一条接收)，可以承载一条或者多条消息\")])]),t._v(\" \"),p(\"li\",[p(\"p\",[t._v(\"消息(message): 与逻辑请求或响应消息对应的完整的一系列帧，这里可以简单理解为一份 http 报文。\")])]),t._v(\" \"),p(\"li\",[p(\"p\",[t._v(\"帧： http/2 的最小通信单位，没个镇包含帧头，至少也会标识出当前帧所属的数据流。\")])])]),t._v(\" \"),p(\"p\",[t._v(\"将上述概念总结一下，就是\")]),t._v(\" \"),p(\"ul\",[p(\"li\",[p(\"p\",[t._v(\"所有通信都在一个 tcp 连接上完成，此连接可以承载任意数量的双向数据流。\")])]),t._v(\" \"),p(\"li\",[p(\"p\",[t._v(\"每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。\")])]),t._v(\" \"),p(\"li\",[p(\"p\",[t._v(\"每条消息都是一条逻辑 http 消息(例如请求或者响应)，包含一个或者多个帧\")])]),t._v(\" \"),p(\"li\",[p(\"p\",[t._v(\"帧是最小的通信单位，承载着特定类型的数据，如 http 标头，消息负载等等，来自不同书籍流的帧可以交错发送，然后再根据每个帧头的数据流标识重新组装\")])])]),t._v(\" \"),p(\"p\",[t._v(\"下面是一个传输过程的快照，方便来理解。\")]),t._v(\" \"),p(\"p\",[p(\"img\",{attrs:{src:_(390),alt:\"\"}})])])}),[],!1,null,null,null);v.default=a.exports}}]);","extractedComments":[]}