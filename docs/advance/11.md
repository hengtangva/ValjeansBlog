# 安全问题

## 前言

对于安全问题，前端主要关注的是 CSRF 和 XSS 攻击     

这里就先对这两个攻击方法进行讨论，以及预防。     

## CSRF 跨站请求攻击

一般能攻击，肯定就是有漏洞存在，我们来看看是什么漏洞，让 CSRF 攻击能发挥其作用。     

首先，我们知道，对于一个域发起请求，如果前一次服务器留有 cookie 的话，下次请求就会带上 cookie(如果浏览器允许的话)      

注意到的是，只要是这个浏览器发送请求，无论从哪个页面发起的请求，都会带上 cookie      

而服务器是不知道是哪个页面发起的请求，只知道是这个客户发来的请求(凭借 识别 cookie)

而有些 cookie 是用来进行身份验证的。      

这就造成了，如果有恶意网站发送同样的请求，并希望服务器更改数据，服务器是分别不出来的，它就会照做。     

来看图，看攻击是如何发生的。     

![](./assets/csrf.jpg)       

---

接下来我们来具体的讲一下，如何发送一个 csrf 攻击      

### 针对 HTTP GET 的 CSRF 攻击

大部分的请求主要是 get 和 post       

我们先来看如何在用户不知道的情况下，如何偷偷发送一个 get 请求      

我们以一个例子来看      

---

假设有一个基于 Web 的网上银行的网址是 www.banker32.com       

它允许用户将自己的资金转到其他人账户上，当然在用户执行该操作之前要登陆该网银行。     

一旦用户登陆，服务器会返回一个会话 cookie ，它标识该用户已经通过了身份验证。      

汇款请求需要一个有效的会话 cookie 否则是不会处理的，而这个 cookie 在登陆状态是给了浏览器的。      

用户可以发送以下请求，来执行转账操作。     

```js
http://www.banker32.com/transder.php?to=3220&amount=500
```      
该请求通知服务器上的 transfer.php 程序执行转账操作，向账号 3220 转账 500 美元。     

---

ok, 如果是用户自己发请求当然没有问题。     

但是，若是攻击者在用户登录状态是时(身份验证的 cookie 是在浏览器这边的)，让用户访问一个精心设计的网页。      

那么，攻击者就可以在这个网站上发送转账请求。     

至于发送 get 请求其实很简单，只需要在网页里加一个 img 或者 iframe 或者 script 标签即可。     

如下：     

```html
<img src='http://www.banker32.com/transfer.php?to=3320&amount=500' alt=''>
```     
这样，解析到该标签时，就会自动发送请求，而用户是不知道的。而由于有之前的 cookie 作为验证，服务器的 transfer.php 会直接执行操作。      

### 针对 HTPP POST 请求的 CSRF 攻击

还是上面的例子，若服务器只支持 post 请求，那么通过 img 标签就不管用了，但是，还是有方法让用户不知道的情况下，发送post 请求。     

我们可以通过 script 脚本动态生成一个表单，来看看是怎么做的。     

```html
<script>
function post() {
    let fields += "<input type='hidden' name='to' value='3220'>";
    fields += "<input type='hidden' name='amount' value='500'>";
    let form = document.createElement('form');
    form.action = 'http://www.banker32.com/postaction.php';
    form.method = 'post';
    form.innerHTML = fields;
    document.body.appendChild(form);
    form.submit();
}

// 网页一加载完成就发起请求
window.onload = () => {
    post();
}
</script>
```      

上面的脚本中，我们动态生成了一个表单，方法是 post，      

注意到的是，我们把表单的的元素全部设置为了 hidden，即不让用户看到。    

解析恶意网页时，scrip 脚本自动执行，伪造请求也就直接发送出去了。      

当然，get 方法也可以这样做，只不过用 img 标签更为方便罢了。      


### 防御措施

我们学习这个。肯定不是为了去攻击别人，肯定是想自己的网站避免被攻击。     

那么如何预防 CSRF 攻击呢？     

我们还是回到开头，看看症结在哪，我们在来对症下药。     

首先，由于服务器时服务区别请求是否跨站的，但是浏览器可以区别的啊。      

所以我们可以从浏览器这边入手，跨站请求就不发送就可以了。      

1. 同站 cookie      

很多浏览器其实已经支持了该方法，      

具体实现是给 cookie 增加一个属性 SameSite, 它有两个值     

该属性由服务器进行设置，它告诉浏览器一个 cookie 是否可以被跨站请求使用     

- SameSite: strict  告诉浏览器该 cookie 只能被同站请求一起发送      

- SameSite: lax  告诉浏览器该 cookie 只有在顶级导航的跨站请求才一起发送     

2. token     

该方法应该是比较主流的做法。     

token 翻译过来是 令牌的意思      

也就是说，用户登录后，服务器会返回一个 token，当然 token 也可以存储在 cookie 里面。      

这时候你可能就有疑问了，那我 CSRF 不是可以借用 cookie 吗？ 你放到 cookie 里面又有什么用呢？      

实际上是这样的， CSRF 攻击只能借用一下 cookie，实际上是利用浏览器的弱点，而实际上它是获取不到 cookie 里的信息的。       

于是，我们自己发送的请求可以这样， http://www.xxxx.com/like?id=12365&token=A23F267AE65      

看到了吗？ 请求里包含了 token 的数据，服务只需要验证 cookie 里的 token 和请求里的是否一样就 ok 了。     

而跨站伪造攻击，只能发送这样的请求，http://www.xxxx.com/like?id=12365   因为它不知道 token 的内容。     

当浏览器发现没有 token 的请求不受理就 ok 了。      

关于 token 的相关知识，建议看一下，登录流程那一部分，有较为详细的解释       

## XSS 跨站脚本攻击

跨站脚本攻击是一种代码注入攻击，这种攻击通常涉及三个实体: 攻击者，被攻击用户，目标网站      

具体实现是怎样的呢？      

攻击者在填写表单或者其他信息的时候，写的是脚本攻击代码，若服务器不做处理的话，当别人访问攻击者的个人信息时，由于，浏览器碰到 script 标签就会执行里面的代码，而不把它当成数据来展示，这就导致了，这断脚本会在受害者浏览器上执行，从而攻击受害者       

典型的 xss 攻击有两种      

### 存储型 xss

存储型 xss 就是我们上述描述的情况。      

攻击者可以直接把数据发送给目标网站，网站会对数据进行持久性储存。      

之后，如果网站将储存的数据发送给其他用户，那么就在攻击者和其他用户之间创建了一条通道     

### 反射型 xss

不知道你有没有碰到这种情况，比如你用谷歌搜索 xyz 时，若没有搜索到，它将返回 ‘找不到与xyz相符的结果’        

很多网站其实都有这样的反射行为，即发出去的东西又被返回回来。      

我们往深的想一下，如果用户发的是恶意脚本呢？       

服务器可能也就会返回该恶意脚本，浏览器又默认执行，就攻击到了用户。       

你可能会想，用户不会那么傻，自己攻击自己。        

是的，但若是攻击做了一个很有吸引人的链接，用户点击了，那么该链接中包含的脚本就会返回到用户的浏览器并执行。      

比如假设有一个存在 xss 漏洞的网站服务：http://www.example.com/serach?input=word        

其中，word 由用户提供。       

若攻击者诱惑用户点击一个链接 ：      

```html
http://www.example.com/search?input=<script>alert('attack');<script>
```    

那么若服务器把 input 里面的数据返回，就会返回一个脚本，从而被浏览器执行，弹出 attack      

### 如何预防 xss

浏览器肯定是做不了什么来预防的。      

所以能实现预防的是服务器。      

我们再来回顾一下，到达为什么会出现 xss 攻击。     

当我们的服务器希望接受的是数据时，恶意用户却给了脚本。那如何把脚本变成数据呢？     

很容易想到的是，将 script 标签转义一下，这样，返回给浏览器的数据就不会被当成脚本执行了。     

举个例子，若有一个恶意用户将恶意脚本注入到一个网页的文本区    

```html
<script>alerr</script>
```     

那么服务拿到之后，要做如下的转义处理，将其转为下面的字符串      

```html
&lt; script &gt; alert('attack') &lt;/script &gt;
```     

浏览器再碰到的时候，就会解析成第一个代码中的字符串，但不会执行 js 脚本。



