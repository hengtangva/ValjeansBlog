# 函数柯里化

## 前言

字节面实习的时候，碰到过这样的面试题         

写一个函数，实现 resolve(1)(2)(3) = 6         

- 一下就懵了，现在已经知道怎么处理了。       

- 代码如下：      

```js
function resolve(a) {
    let sum = a
    return (b) => {
        sum = sum + b;
        return (c) => {
            sum = sum + c;
            return sum;
        }
    }
}
```        
---     

- 因为返回的是函数，因此可以继续传参执行，链式调用下去。        

- 再走深一点，我们这里已经固定死了 3 层，能否不固定层数呢？          

- 可以考虑的思路是递归。          

- 由于我们实际无法判断到底调用什么时候截止，因此可以做一个前设条件，以不传参() 为结尾

```js
function resolve(a) {
   let sum = a;
   return function temp(b) {
       if(arguments.length === 0) {
           return sum;
       } else {
           sum = sum + b;
           return temp;
       }
   }
}

console.log(resolve(1)(2)(3)()); // 6
```       

- 本质上是对闭包的一个应用。             

- 那么上面的例子和柯里化有什么关系呢？        

## 柯里化

:::tip
柯里化（Currying）: 把接受多个参数的函数转换成接受一个单一参数的函数
:::       

- 简单的说，就是可以让函数可以对对传入的参数分步调用。      

- 一次调用的返回函数中，保存了上次的传参(通过闭包得以实现)        

我们可以实现一个 柯里化函数 curry，传入一个函数参数，返回一个柯里化后的函数。      

- 由于我们传入的函数是有参数的，因此，我们实际上可以通过参数的长度知道递归的层数的。        

- 也就没有必要最后通过传空参数 () 来作为递归的结束了。      

```js

```

