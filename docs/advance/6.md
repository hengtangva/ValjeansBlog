# htpp 1.0/1.1/2.0/3.0
## 前言

## http 2.0
这里先主要讲一下 http 2.0    

提到 2.0  当然就得先提到 1.1 有哪些问题，然后 2.0 是如何解决这些问题的。     

1. 一个 tcp 连接上，一次只能发送一个请求，如果有多个请求，就会排队等待。     

2. 头部冗余，采用文本格式传输。    

3. 客户端需要主动发送请求。    

再来看 http2.0 是如何解决这些问题的。     

### 多路复用

名如其意， 多路复用就是考虑，让一个 tcp 连接能同时发送多个请求，当然和进程一下，这里是并行，不是并发。     

如下图：     

![](./assets/http2roads.jpeg)    

想要实现该如何做到呢？     

我们先来想象一下，多个请求并发的情况是如何。     

建立一个 tcp 连接后，客户端发一个请求，只有等到服务器返回响应了，才能发送下一个请求。     

但 http2 不一样，它可以在第一个请求还没收到响应就继续发另请求，     

带来的好处是，各个请求到接受反应的时间大大缩小。     

但也带来一个问题，就是比如第一个请求稍有些延迟，后一个请求先到了，并且后一个响应也先到浏览器这边。     

那么我怎么才能知道，哪个请求对应的响应是哪个呢？      

这时候就需要对发的数据进行编号，这也正是我们的 http2 所干的事情。     

---    

我们这里还要说到一个概念  **二进制分帧层**     

二进制分帧层介于应用层和传输层之间     

它会把 http2 传输的信息分隔为帧(frame)，并对他们采取二进制格式的编码，其中首部信息会被封装到 headers frame 中， request body 的数据则封装到 data frame 中，如下图所示        

![](./assets/binary_framing.svg)      

到这里我们了解了。    

http2 主要是把 http报文 分为更小的数据块(帧)，并标记，编码成二进制。从而达到并行发送的效果，接收方，只需按照标记的规则把数据重组为 http 报文就 ok 了      

---

再接着了解一下几个概念，方便我们对后面的过程有更清楚的了解。     

1. 数据流： 已经建立连接内的双向字节流(一条发送，一条接收)，可以承载一条或者多条消息     

2. 消息(message): 与逻辑请求或响应消息对应的完整的一系列帧，这里可以简单理解为一份 http 报文。     

3. 帧： http/2 的最小通信单位，没个镇包含帧头，至少也会标识出当前帧所属的数据流。    

将上述概念总结一下，就是      

- 所有通信都在一个 tcp 连接上完成，此连接可以承载任意数量的双向数据流。     

- 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。      

- 每条消息都是一条逻辑 http 消息(例如请求或者响应)，包含一个或者多个帧     

- 帧是最小的通信单位，承载着特定类型的数据，如 http 标头，消息负载等等，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识重新组装     

下面是一个传输过程的快照，方便来理解。     

![](./assets/stream.svg)

总而言之，通过二进制分帧层，我们使得多路复用这个方法得以实现，从而大大提升传输效率。    

### 头部压缩
每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。 为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，     

具体做法是维护表，将常见字段和值都放到表里。      

我们就可以把 头部用表中各个字段的索引代替，传到另一端的时候，只需查表，就可以恢复头部了。     

这样就把一个字段变成了一个字节的数字，从而大大压缩了头部的字段。     

表有两张，一张是静态的，即我们常用的，可以通官方网站查到      

![](./assets/http2table.jpg)      

还有一张表是动态的，是可以随意添加的，比如之前传过来的头部有的字段和值不在表中，     

我们就可以将其加入表中，下次若还传一样的，只需传索引即可。     

若表中有的字段只给了名称，没有值 如 cookie ，便第一次可以用哈夫曼编码把这些值压缩再传递。     


### 服务器推送

服务器推送也和字面理解差不多，即客户端没有发送请求，服务器也把数据发送过去。     

当然服务器不是乱发的。举个例子     

当客户端请求  html 页面时，服务器发现这个 html 文件还依赖一些其他的 css 文件，以及 js 文件，     

服务器就会通过服务器推送，把这些数据推送给客户端，(毕竟客户端肯定是要用的，既然请求了该 html 文件的话)     

总而言之，就是一份请求，发送多个响应。     

看图吧：     

![](./assets/serverpush.svg)      

















