# 客户端和服务端渲染

            
## 前端渲染-CSR       

Client-Side-Rendering

前端渲染一般是单页富应用的项目，简称 SPA          

整个 web 应用实际只有一个页面， 当 url 发生改变的时候，不会从服务器请求新的静态资源               

而是通过 js 监听 url 的改变，并根据不同的 url 去渲染新的页面。        

对于单页富应用的项目，打包后，我们可以发现，入口文件  index.html 其实什么都没有。             

只有一个 

```html
<div id="app"></div>
``` 
最后渲染出什么，全靠下载 js 代码，然后执行 js 代码，动态生成 html 的结构。           

导致的问题有以下几个           

1. 由于页面的生成经过了很多步，所以用户的首屏加载时间会比较长
    - 一开始的 index.html 的下载
    - js 资源的下载，
    - js 的执行
    - js 的网络请求资源
    - 最后浏览器拿到全部的 css 和 html 渲页面          

2. 对于搜索引擎，比如 百度，它不会把你的 js 下来执行一遍再去爬取信息，只会直接爬你 index.html 的信息，最后发现啥都没有。于是你的网页排名就会很低。这方面的问题的优化，我们通常称为 seo 优化

## 服务端渲染-SSR

Server-Side-Rendering          

在后端把所有资源整合起来，形成一个个页面。并对于一个 url          

前端只需输入对应  url 即能得到完整 html 文档，并直接渲染出页面        

这种情况，不需要加载任何 js， css ，可以直接给浏览器展示，有利于 seo 优化。          

---          

- 所以，我们问题在于我们要能再后端把所有页面都渲染出来。直接生成比较完整的 html 文件给客户端。        

- 而这里的渲染无非是执行 js 代码，所以，在我们的 node 环境即可实现。            

----        

然后再介绍一下**同构**         

1. 一套代码既可以在服务端运行，又可以在客户端运行，这就是同构应用。            

2. 同构是一种 SSR 形态，是现在 SSR 的一种表现形式。            

3. 当用户发出请求时，现在服务器通过 SSR 渲染出首页内容。          

4. 但是对应的代码同样可以在客户端被执行。            

5. 执行的目的包括事件的绑定等以及其他页面切换时也可以在客户端渲染。              


## 总结

服务端渲染框架：         

- Vue: Nuxt.js     详见 vue 部分知识       

- react: Next.js      详见 react 部分知识        
 



