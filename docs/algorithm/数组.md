# 数组

## 前言

这里存的主要是一些数组的题目，由于归类不到其他的类型，但此间还是有些东西，因此单独放一节。         


## leetcode.31-下一个排列

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。        
 
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。         

必须 原地 修改，只允许使用额外常数空间。         

示例 1：        
 
输入：nums = [1,2,3]         
输出：[1,3,2]       

---          

- 思路        

思路还是要想好一会。           

1. 首先，我们可以从后往前遍历，一旦 nums[i] > nums[i-1] 就说明只需将二者换一下就能得到大一些的排列。         

2. 但是，这不一定是比原排列大的下一个排列。举个例子。         

    - 4,2,3,1 从后往前遍历，发现 3 > 2          

    - 交换二者后，得到 4,3,2,1 , 但实际上写一个排列是 4,3,1,2               

3. 有一点我们是可以肯定的，找到对应的 i 之后，只需对 i-1 之后的数组进行操作，若找不到，直接转置数组(因为当前排列数最大值)。          

4. 我们接下来操作 i-1 - len-1 这一段数组。           

    - 第一个注意的点是 i-1 这个位置应该放哪个数，很显然，如果 i 后面还有比它大的数，我们取最小的那个，这样刚好能大一点，处于下一个排列。       

    - 而这个数很容易得到，因为我们之前遍历的 i - len-1 是逆序的，只要从后往前找到第一个比 i-1 大的数即可，设其为 j。        

    - 我们将 i-1， j 进行交换，此时只需关注 i - len-1 了。可以发现这一段数组是逆序的，而 i-1 已经比原来大一点了。所以我们只需要把逆序改成顺序(转置)，即为最小值，即刚好下一个排列。       

5. 最后对与交换和转置，我们都可以单独抽出函数，方便理解主函数的逻辑。         

```js
 var nextPermutation = function(nums) {
    let len = nums.length;
    if(len === 1) {
        return;
    }
    for(let i = len - 1; i > 0; i--) {
        if(nums[i] > nums[i-1]) {
            // 找到顺序的 i-1
            for(let j = len-1; j >= i; j--) {
                // 找到刚好比 i-1 大的数
                if(nums[j] > nums[i-1]) {
                    swap(nums, i-1, j);
                    // 把后面的逆序改成顺序
                    myReverse(nums, i, len-1);
                    return;
                }
            }
        }
    }
    nums.reverse();
    return;
};

function swap(nums, i, j) {
    let temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
function myReverse(nums, i , j) {
    while(j > i) {
        swap(nums, i, j);
        i++;
        j--;
    }
}
```       

---      

