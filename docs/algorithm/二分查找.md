# 二分查找

二分查找，可以看成是双指针的一个特例，一般用二分查找可以将时间复杂度由 O(n)  降为 O(logn).    

原理其实也比较简单。    

1.  定义头指针 head ，尾指针 tail    

2.  每次让中间指针 mid = parseInt((head + tail)/2)    

3.  若 mid 指向要查找的值，就找到了，接着后续处理。    

4.  若 mid 的值大，尾指针 tail = mid - 1    

5.  若 mid 值小，头指针 head = mid + 1    

6.  只要 tail >= head ,就让重复执行 2,3,4,5 操作。    

先从一个最简单的例子开始我们的二分查找。    

##  leetcode.69 x 的平方根

实现 int sqrt(int x) 函数。     

计算并返回 x 的平方根，其中 x 是非负整数。    

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。     

示例 1:    

输入: 4     
输出: 2     

**思路**     

我们可以设置两个指针，头指针和尾指针，来确认查找范围。    

一开始头指针是 0 ，尾指针是 x    

不断求 mid = (head + tail) / 2 ，由于用的是 js， 所以这里要用 parseInt。    

直到头尾指针相邻，就说明找到头了，由于是向下取整，所以我们返回头指针即可。    

code：    

```js
var mySqrt = function(x) {
    if(x === 0) {
        return 0
    }
    if(x < 4) {
        return 1;
    }
    let head = 0,
        tail = x;
    while(head+1 !== tail) {
        let mid = parseInt((head + tail)/2);
        if(mid * mid > x ) {
            tail = mid;
        }
        else if(mid * mid < x) {
            head = mid;
        } else {
            return mid;
        }
    }
    return head;
};
```    

---

好了，了解二分查找过程了， 我们来让情况复杂一些，看下面题目。      

## leetcode.1011- 在 D 天内送达的包裹

传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。       

传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。       

返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。       

示例 1：       

输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5        
输出：15        
解释：        
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：       
第 1 天：1, 2, 3, 4, 5      
第 2 天：6, 7       
第 3 天：8        
第 4 天：9       
第 5 天：10        

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。        

---      

- 思路     

首先，由于数组的顺序是不能改变的，而里面的货物重量又是随机的。        

所以找不到什么规律，一开始，自己想的是找平均值，然后贪心遍历，一旦大于平均值，就把该次装货设为运载量          

不过，貌似不行，因此没有任何规律。       

所以，这时候，就得一个个试，去查找了。       

不过，查找是可以优化的。          

1. 首先，运载量最低肯定要大于最重的货物，最大不可能超过货物的重量总和。          

2. 其次，查找的时候是可以二分查找的，因为一旦一个运载量能再 D 天完成，那么运载量大于它也是可以在 D 天内完成的，而我们要找的是这个最低的运载量，        
    - 因此只要 运载量 x 所需天数大于 D ，就在右边找，        
    
    - 运载量小于等于 D ，就往左边找。值得注意的是，我们是要找最小的，所以等于 D 还不一定最小的，还得继续往左边找，直到接近 D+1 天时，才是最小的。        

codes：        

```js
var shipWithinDays = function(weights, D) {
    // 贪心
    let sum = weights.reduce((pre, cur) => {
        return pre+cur;
    })
    if(D === 1) {
        return sum;
    }
    let left = Math.max(...weights);
    let right = sum;
    while(left < right) {
        let mid = parseInt((left+right)/2);
        let day = 1;
        let cur = 0
        for (const weight of weights) {
            if (cur + weight > mid) {
                day++;
                cur = 0;
            } 
            cur += weight;
        }
        if(day > D) {
            left = mid + 1;
        }
        else {
             right = mid; 
        }  
    }
    return left;
};

console.log(shipWithinDays([10,50,100,100,50,100,100,100], 5));
```     

**总结**       

如果发现实在没有规律的话，就只得查找了，但是我们可以优化查找，比如使用二分，缩小边界等。     



## leetcode.34 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。    

如果数组中不存在目标值 target，返回 [-1, -1]。     

进阶：      

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？      
 
示例 1：     
输入：nums = [5,7,7,8,8,10], target = 8      
输出：[3,4]      

**思路**     

由于数组是有序的，我们还是可以通过二分查找，来达到 O(log2N) 的事件复杂度。     

先是二分查找是否存在，该数字，找的话，再两边扩展即可。    

```js
var searchRange = function(nums, target) {
    if(!nums) {
        return [-1, -1]
    }
    let len = nums.length;
    if(len == 0) {
        return [-1, -1];
    }
    if(len === 1) {
        return (target === nums[0])? [0,0]:[-1,-1];
    }
    let head = 0,
        tail = len -1,
        start,
        end;
    while(head <= tail) {
        let mid = parseInt((tail + head)/2);
        if(nums[mid] === target) {
            start = mid;
            end = mid;
            while((start > 0 && nums[start -1] == target) ||(end < len- 1 && nums[end + 1]) === target)             {
                if(nums[start - 1] === target) {
                    start--;
                }
                if(nums[end + 1] === target) {
                    end++;
                }
            }
            return [start, end];
        }
        else if(nums[mid] > target) {
            tail = mid -1;
        }
        else {
            head = mid + 1;
        }
    }
    return [-1,-1]
};
```    

上面都是排序好的数组，如果是只有一部分排序好的，该怎么处理呢？    

---

## leetcode.153 寻找旋转排序数组中的最小值

假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。    

请找出其中最小的元素。     

示例 1：    
输入：nums = [3,4,5,1,2]     
输出：1     

**思路**    

为了降低时间复杂度，我们还是选择二分查找，    

1. head 指针指向开头， tail 指针指向末尾。    

2. mid = parseInt((head + tail)/2)    

3. 数组旋转后，形成了先升，再突然降一步，再接着升的效果。     

所以，如果一个数的前面一个数比他大，那么这个数就是滑坡所在了，就是最小值。    

如果一个数后面一个数比他小，那么它后面这个数就是滑坡所在，是最小值。    

4. 如那么如果不满足上点条件，head ，tail 指针如何移动呢？我们可以和 nums[0] 来比较。    

如果，mid 比 nums[0],大，明显，mid 是在左边的升序中，滑坡点在其右边，此时 head = mid + 1.    

否则，mid 就是处于右边的升序中，滑坡点在其左边，此时 tail = mid - 1 。    

codes：     

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    let head = 0,
        tail = nums.length - 1;
    if(!tail) {
        return nums[0];
    }
    if(nums[tail] > nums[head]) {
        return nums[head];
    }
    while(tail >= head) {
        let mid = parseInt((tail + head)/2);
        if(nums[mid-1] > nums[mid]) {
            return nums[mid];
        } 
        if(nums[mid] > nums[mid+1]) {
            return nums[mid+1];
        }
        if(nums[mid] > nums[0]) {
            head = mid + 1;
        }
        else {
            tail = mid - 1;
        }
    }
};
```    

总而言之，就是二分查找缩减区间的判断不一定非是比较大小，只要能确定目标所在区间范围，都可以二分查找。    

下面这个例子，也很好解释了这一点。    

## leetcode.540 有序数组中的单一元素
给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。    

示例 1:     

输入: [1,1,2,3,3,4,4,8,8]     
输出: 2      

**思路**     

二分查找过程这里就不再说了，找目标数，只要左边或右边有一个数和它一样就找到了。    

主要是谈一下，怎样移动 head 和 tail 指针    

我们可以明显看到奇偶性，假如目标数在左边的话，左区间一定有奇数个数字，否则就在右边，    

当然我们还得分类讨论一下，自己找的 出现两次数的数，是左边那个，还是右边那个，右边的话，左区间就一定有偶数个数字    

codes:    

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate = function(nums) {
    let head = 0,
        tail = nums.length - 1;
    while(tail >= head) {
        let mid = parseInt((head + tail)/2);
        // 找到出现唯一的数，就 return
        if(nums[mid+1] !== nums[mid] && nums[mid-1] !== nums[mid]) {
            return nums[mid];
        }
        // 说明是两次出现数左边的数
        if(nums[mid - 1] !== nums[mid]) {
            if(mid%2 == 0) {
                head = mid + 1;
            } else {
                tail = mid - 1;
            }
        }
        // 右边的数
        if(nums[mid + 1] != nums[mid]) {
            if(mid%2 == 1) {
                head = mid + 1;
            } else {
                tail = mid - 1;
            }
        }
    }
};
```       


