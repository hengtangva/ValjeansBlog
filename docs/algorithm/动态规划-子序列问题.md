# 子序列问题

## 前言

这里主要是收集了最长递增子子序列之类的问题

## leetcode.300-最长递增子序列
 
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。         

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。          

示例 1：          

输入：nums = [10,9,2,5,3,7,101,18]           
输出：4          
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。        

---         
- 思路        

- 字节提前批碰到了，之前虽然做过，但是这次却没啥头绪。          

- 这里首先要明白，动态规划的 dp[i] 该设为什么。        

- 我们这里应该设为 以 nums[i] 为结尾的最长递增子序列长度。         

    - 这样，我们可以列举出所有的结果，因为无论哪个子序列最后一个元素肯定还是会再数组里的。        

    - 除此之外，我们还存储了一个很重要的信息，最后一个结尾的数(即该子序列的最大的数)      

    - 如此我们便很容易推导出状态方程。        

- 状态方程
    - 很明显，如果一个数 i > j, 如果 nums[j] > dp[i] 那么 nums[j] 肯定可以做为一个更长递增子序列的结尾。       

    - 而我呢需要的是满足上述条件的最大的那个 j ，因此我们需要两重循环遍历。       

    - dp[i] = Math.max(dp[j])+1 && nums[i] > nums[j]      

- 代码如下：    

```js
var lengthOfLIS = function(nums) {
    let len = nums.length;
    if(len == 1) {
        return 1;
    }
    const dp = new Array(len).fill(1);
    for(let i = 1; i < len; i++) {
        let max = 0;
        // 我们需要去找前面的最长递增序列，并且它最后一个数还是小于 nums[i] 的
        // 这样，nums[i] 才能加进去组成更长的地递增序列
        for(let j = 0; j < i; j++) {
            if(nums[j] < nums[i]) {
                max = Math.max(max, dp[j])
                dp[i] = max + 1
            }
        }
    }
    // 最后，返回 dp 中最大的那个数即可
    return Math.max(...dp);
}
```     

- 下面这题和上面的 dp[i] 定义的一样，对于 dp[i] 定义的场景可以比较一下得出自己的结论            

## 剑指 Offer 42. 连续子数组的最大和
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。        

要求时间复杂度为O(n)。        

示例1:        

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]       
输出: 6         
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。剑指 Offer 42. 连续子数组的最大和        
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。         
 
要求时间复杂度为O(n)。        

---       

- 思路        

比较直观的方式是滑动数组，这样只需要遍历一遍，记录一下状态就可以了。         

不过也可以用动态规划来解决问题。          

难点在于状态的设计，这里的 dp[i] 的意思是以 nums[i] 结尾的子数组最大的值是多少。          

后面思路就比较清晰了。       

状态方程可以直接给出 dp[i] = Math.max(dp[[i-1]+nums[i], nums[i])           

最后我们用一个变量记录最大值，返回即可。          

```js
var maxSubArray = function(nums) {
    const dp = new Array(nums.length).fill(0);
    dp[0] = nums[0];
    let ans = nums[0];
    for(let i = 1; i < nums.length; i++) {
        dp[i] = Math.max(nums[i], dp[i-1]+nums[i]);
        ans = Math.max(ans, dp[i]);
    }
    return ans;
};
```

---    

- 下面来个简答的稍微休息一下      

## leetcode.674-最长连续递增序列      

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。          

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。       

示例 1：         

输入：nums = [1,3,5,4,7]         
输出：3            
解释：最长连续递增序列是 [1,3,5], 长度为3。        
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。            

---      

- 思路      

- 由于需要连续，因此就简单多了，一遍遍历就可以了。      

- 这里我们的 dp[i] 同样定义为 以 nums[i] 结尾的子数组      


```js

var findLengthOfLCIS = function(nums) {
    let len = nums.length;
    if(len === 1) {
        return 1;
    }
    // dp[i] 同样能定义为 以 i 结尾的连续子数组
    const dp = new Array(len).fill(1);
    for(let i = 1; i < len; i++) {
        if(nums[i] > nums[i-1]) {
            dp[i] = dp[i-1] + 1;
            continue;
        }
    }
    return Math.max(...dp);
};
```          


