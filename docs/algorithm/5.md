# 双指针

双指针其实我们之前自己就已经用过了，    

我们的用一前一后两个指针来对相邻元素进行比较，    

其实我们的指针还可以首指针，尾指针来共同遍历，此类解题方法不唯一，不好总结，看例子吧。    

## 多数之和以及其延伸

先来看最简单的二数之和用双指针。    

### leetcode.167 两数之和 II - 输入有序数组    

给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。    

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。     

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。    
 
示例 1：    
输入：numbers = [2,7,11,15], target = 9     
输出：[1,2]     
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。     

**思路**    

思路真没什么，头指针，尾指针遍历就是了。    

codes：    

```js
var twoSum = function(numbers, target) {
    let res = [],
        len = numbers.length;
    if(len === 1 || !numbers) {
        return [];
    }
    let head = 0,
        tail = len - 1;
    while(tail > head) {
        let sum = numbers[head] + numbers[tail];
        if(sum === target) {
            res.push(head + 1);
            res.push(tail + 1);
            break;
        }
        else if(sum > target) {
            tail--;
        } else {
            head++;
        }
    }
    return res;
    };
```

## 归并数组

再来看看归并数组中的双指针的用法。       

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。    

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。      

示例 1：     
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3    
输出：[1,2,2,3,5,6]     

---
**思路**    

解决问题其实很简单，先切割，再合并，最后排序，就 ok 了。

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m, m + n);
    nums1.push(...nums2);
    nums1.sort((a, b) => a -b);
};

```    
但是    
时间复杂度 : O((n + m)\log(n + m))O((n+m)log(n+m))。     
空间复杂度 : O(1)O(1)    

我们现在来用双指针来降低其时间复杂度。    

## 快慢指针

## 滑动窗口
