
# 动态规划

::: tip
动态规划实质是建表
:::

## 题目 最长回文子串
给你一个字符串 s，找到 s 中最长的回文子串。

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案

思路： 两个指针，一个 i 指针从头走，j 指针从尾走，碰到回文串就与之前存在 result 的回文串 比较长度
 比之前的长就更新 result 数组，否则跳过，j 走一轮后，i 往前走一格。
```js
 var longestPalindrome = function(s) {
    let arr = Array.from(s);
    let len = arr.length;
    let result = [];
    if(len === 1) {
        return arr.join('');
    }
    if(len === 2) {
        if(arr[0] == arr[1]) {
            return arr.join('');
        } else {
            return arr[0];
        }
    }
    for(let i = 0; i < len - 1; i++) {
        let j = len - 1;
        while(j >= i) {
            let head = i,
                tail = j;
            while(arr[head] === arr[tail]) {
                / 考虑回文串是奇数串，还是偶数串
                if(tail === head || (tail - head == 1)&&(arr[head]==arr[tail])) {
                    if(j - i + 1 > result.length) {
                        result = arr.slice(i,j+1);
                    }
                    // 当回文串长度大于 原串长度 - 起始指针i 的时候，后面的串就不可能大于它了，直接返回即可
                     if (result.length >= len - i) {   
                        return result.join('');
                    }
                    break;
                }
                head++;
                tail--;
            }
            j--;
        }
    }
    return result.join('');
};
```
::: tip
动态规划的解法：建表，用表的空间换取时间，
不过貌似这里的动态规划没有自己的优化代码性能好
细节见： https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/
:::


## 动态规划解法如下

```js
var longestPalindrome = function(s) {
   let arr = Array.from(s);
   let len = arr.length;
   let dp = new Array(len);
   for(let i = 0; i < len; i++) {
       dp[i] = new Array(len);
       dp[i][i] = true;
   }
   let begin = 0,
       max = 1;
   for(let j = 1; j < len; j++) {
       for(let i = 0; i < j; i++) {
           if(arr[i] !== arr[j]) {
               dp[i][j] = false;
           } 
           if(arr[i] === arr[j]){
               if(j - i > 1) {
                    dp[i][j] = dp[i+1][j-1];
               } else {
                   dp[i][j] = true;
               }
           }
           if(dp[i][j] == true && j - i + 1 > max) {
               max = j - i + 1;
               begin = i;
           }
       }
   }
   return arr.slice(begin,begin + max).join('');
};
```
