# 原地 hash    

这里不仅仅包括 hash 表，对于能修改的数组。            

如果可以的话，我们可以尝试尽量用原数组来存取状态，这样可以将空间复杂度降下来。          

## leetcode.41-缺失第一个正数          

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。         

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。        

示例 1：        

输入：nums = [1,2,0]          
输出：3        

---          

- 思路        

自己是一点思路没有，参考题解            

首先如果不是时间和空间复杂度要求的话，自己的思路有一下几个。          

- 排序，再遍历。可是最好的堆排序也只稳定在 logN， 桶排序需要 O(n) 空间复杂度         

- 用 map 存储一下状态，值为 key， 再从 1 到 n 遍历，一旦 map 中不存在，说明就是最小缺失的了。          

官方题解思路：          

- 首先 O(n) 时间复杂度，常数空间复杂度是不存在的。             

- 但由于可以修改数组，因此我们可以用原数组来做 hash 表，类似于合并两个有序数组一样           

具体做法如下：          

1. 第一遍遍历数组，把所有负数改为 length + 1 因为我们打算用负数来做标价，得先消除负数的影响。          

2. 第二遍遍历数组，我们来制作 hash 表            

    - 由于数组索引刚好是 1-n， 因此是一个极好的映射。           

    - 我们的映射关系是这样的，nums[i] < 0 表示 第 i 个数数组里存在。           

    - 我们要做的就是 碰到 nums[j] === k (1 <= k && k <= n) 时，让 nums[k-1] 取负数作为标记。         
    
    - 由于我们的 nums[k-1] 也需要做为标识去标识其他的位置，因此只需拿到其绝对值取反即可。             

3. 第三遍遍历数组，一旦碰到第一个 大于 0 的数，说明该数不存在，拿到其索引 + 1 即为结果            

```js
 var firstMissingPositive = function(nums) {
    let len = nums.length;
    // 先去除本来存在的负数的影响，因为我们是用负数来打标记的
    for(let i = 0; i < len; i++) {
        if(nums[i] <= 0) {
            nums[i] = len+1;
        }
    }
    for(let i = 0; i < len; i++) {
        let num = Math.abs(nums[i]);
        if(num <= len) {
            nums[num-1] = -Math.abs(nums[num-1]);
        }
    }
    for(let i = 0; i < len; i++) {
        if(nums[i] > 0) {
            return i+1;
        }
    }
    return len+1;
};
```
