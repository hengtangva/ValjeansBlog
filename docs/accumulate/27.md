# 迭代器

## 什么是迭代

迭代的意思是，重复，再来的意思。对于代码来说，就是按照一定顺序反复执行一段程序。     

比如下面的技术循环就是一种最简单的迭代     

```js
for(let i = 1; i < 10; i++) {
    console.log(i);
}
```     
迭代会在一个有序集合上进行，我们最熟悉的就是数组了，来看数组的迭代。     

```js
let srr = [1,2,3,4];
for(let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}
```     

但是，这里的循环迭代反映出来一些问题。     

- 迭代之前需要知道如何使用数据结构，比如数组就得用下标引用，如果我本身不知道他数数组还是 set 还是其他呢？，可以迭代吗？    

- 遍历顺序不是数据结构固有的，通过增加索引来访问数据是特定于数组的形式。     


所以，我们的 迭代器出现了，目的是让所有，有顺序的数据结构都能进行迭代。     

## Iterable 接口

es6 提供了一个解决方案，凡是实现了 iterable 接口的对象(或者数据结构)，都可以被迭代。     

我们知道的 数组，set，map 等，其实内部已经实现了 iterable 接口。    

当然，你想自己实现一个数据构造函数让它的实例都是可以迭代的，你也可以在构造函数中实现这个接口。    

实现这个接口有啥好处呢？    

实现后，我们就可以用 for..of 来迭代对象了。     

```js
let arr = [1,2,3,4];
for(let item of arr) {
    console.log(item);
}

let set = new Set(arr);
for(let item of set) {
    console.log(item);
}

//......
```    

只要实现了 iterable 接口，我们都叫这个对象可迭代对象。    

下面我们自己来实现 iterable 接口，这个接口函数名叫 \[Symbol.iterator\]      

```js
class Foo {
    constructor(limit) {
        this.limit = limit;
    }
    [Symbol.iterator]() {
        let count = 1,
            limit = this.limit;
        return {
            next() {
                if(count < limit) {
                    return {done: false, value: count++}
                }
                else {
                    return {done: true, value: 'foo'}
                }
            }
        }
    }
}
let foo = new Foo(5);
for(let item of foo) {
    console.log(item);
}
// 1
// 2
// 3
// 4
```    

可能看着有些奇怪，奇怪的地方，我们后面说，但通过实现 这个接口，我们的确可以用 for...of 迭代了。     

好了，再来关注奇怪的部分。    


